---
title: BIO NIO AIO的区别
tags: 
- java
category:
- 手记
---
本人比较喜欢带着问题去学习 , 学习之前我们先问自己两个问题 , 方便能找到问题答案
```
	1、什么是IO
	2、同步、异步、阻塞、非阻塞分别是什么 , 用来干什么
```
## IO介绍

我们通常说的IO其实就是Input/Output的缩写 , 中文即输入、输出的缩写

### 1. BIO、NIO、AIO的区别

#### 1.1 BIO(Blocking IO)

即同步阻塞IO，是流的基本实现方式，交互时是同步阻塞的方式，也就是说在读取或写入流未完成时，线程会阻塞在那里<br>调用时是十分可靠的，因为线程是安全的，毕竟在没操作完之前都会锁住<br>优点：实现简单、线程安全<br>缺点：效率低、扩展性差（就是不在能同一时刻做多个事情）。

#### 1.2 NIO(UnBlocking IO)

即同步非阻塞IO，是基于事件和回调机制实现，主要是解决BIO的高并发的问题：在网络应用中，如果要同时处理多个请求，就要使用多线程。也就是说，将每个请求给一个线程进行单独处理，虽然能理论上能解决，但实际是残忍的。每创建一个线程就需要系统分配一定的内存空间，而操作系统本身对线程总数就有一定的限制。所以如果请求过多，服务器可能会拒绝请求，甚至会宕机。当socket有流可读或者可写时，操作系统会通知应用程序进行处理，应用程序再处理这个流。也就是说，这个时候，这个流是有效的，不再是以前的有一个请求就创建一个线程了，当socket没有数据时，是没有线程来进行处理。<br>优点：效率高<br>缺点：编码会复杂、要处理半包的情况。

#### 1.3 AIO(Asynchronous IO)

即异步非阻塞IO，是基于事件和回调机制实现，也就是在操作完成之后，会直接返回，不会阻塞在那里，当后台处理完成之后，会通知相应的线程进行后续的操作<br>优点：可以异步、效率高<br>缺点：会比一个线程读取数据复杂。

## 同步、异步、阻塞、非阻塞

上面解释了一下IO的是什么，但是引入了同步、异步、阻塞、非阻塞的概念，现在解释下这些概念。

### 1. 同步与异步

#### 1.1 同步

当一个A任务需要依赖B任务时，A任务只有等到B任务结束才能继续执行，这是线程安全的。要么都成功，要么都失败，两个任务的状态是一致的。就像打电话一样，一方挂掉，电话就挂掉了。

#### 1.2 异步

还是A任务需要依赖B任务，这时A任务不再等到B任务处理结束了。只是A会通知B去完成某个任务，但是B是否真的完成，A是不关心的，所以异步是不可靠的任务。像发短信一样，只要发出去，对方是否收到，不去关心。

### 2. 阻塞与非阻塞

#### 2.1 阻塞

这个得从CPU上说起，阻塞就是CPU停下来等待一个慢的操作完成，CPU才能接着完成其他的事情。

#### 2.2 非阻塞

就是CPU不等待那个比较慢的操作，先去做其他的事情，等这个比较慢的操作完成后，再进行处理他的后续操作。这样可以明显提高CPU的使用率，但是也增加了CPU在各个线程之间的切换，这个切换是要消耗资源。增加CPU使用时间的效率是否大于CPU切换线程的时间，需要好好评估之后再使用

#### 2.3 同/异、阻/非堵塞 组合

同/异、阻/非堵塞的组合，有四种类型，如下表：<br>

组合方式 | 性能分析   
-|-
同步阻塞 | 最常用的方式，但是I/O性能比较差，CPU存在大部分空闲时间 | 
同步非阻塞 | 提升I/O性能的常用方法，就是将I/O 的阻塞改成非阻塞方式，<br>尤其在网络I/O是长连接，同时传输数据也不是很多的情况下，提升性能非常有效。<br>这种方式通常能提升I/O性能，但是会增加CPU消耗，<br>要考虑增加的I/O性能能不能补偿CPU的消耗，也就是系统的瓶颈是在I/O还是在CPU上。 | 
异步阻塞 | 这种方式在分布式数据库中经常用到，<br>例如在网一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，<br>而还有两至三份是备份记录会写到其它机器上，<br>这些备份记录通常都是采用异步阻塞的方式写I/O。<br>异步阻塞对网络 I/O 能够提升效率，尤其像上面这种同时写多份相同数据的情况。 | 
异步非阻塞 | 这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下使用，<br>像集群之间的消息同步机制一般用这种 I/O组合方式。<br>它适合同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大，<br>但是却非常频繁。<br>这种网络I/O用这个方式性能能达到最高。 | 
